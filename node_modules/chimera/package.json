{
  "name": "chimera",
  "author": {
    "name": "Dean Mao",
    "email": "deanmao@gmail.com"
  },
  "description": "chimera",
  "version": "0.3.2",
  "main": "./lib/main.js",
  "engines": {
    "node": ">= 0.6"
  },
  "dependencies": {
    "request": "~2.12.0"
  },
  "devDependencies": {
    "aws-sdk": "git://github.com/aws/aws-sdk-js.git"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/deanmao/node-chimera.git"
  },
  "scripts": {
    "postinstall": "node scripts/download_native_binary.js"
  },
  "readme": "# Chimera: A new kind of phantom for NodeJS\n\nI was inspired by [PhantomJS](http://phantomjs.org) and wanted something similar, but could be run inside of the nodejs\nenvironment, without calling out to an external process.  PhantomJS is run as an external process that users can run\nunder any language, however one must create a fancy glue wrapper so that development isn't impaired.  I created\nsomething that does exactly what phantomjs is capable of doing, except in a full js environment, called Chimera.\n\n## Installation\n\nInstalling is simple via npm:\n\n    npm install chimera\n    \nIt will download the native chimera binary in the postinstall script.  Currently we have binaries for 64bit darwin (mac),\nand 64bit linux.  If you use something different, you may have to compile your own or wait for me to build one for your\nplatform.\n\n## Usage\n\nThe most basic skeleton should look something like this:\n\n    var Chimera = require('chimera').Chimera;\n\n    var c = new Chimera();\n    c.perform({\n      url: \"http://www.google.com\",\n      locals: {\n\n      },\n      run: function(callback) {\n        callback(null, \"success\");\n      },\n      callback: function(err, result) {\n    \n      }\n    });\n\nWhen you instantiate a new chimera with `new Chimera()`, you're actually creating a new browser instance which does\nnot share session data with other browser sessions.  It has it's own in memory cookie database and url history.  \n\nThe `locals` hash should contain variables you wish to pass to the web page.  These values should be types that can be\nturned into json because the sandboxing environment of the browser's js engine prevents us from passing actual nodejs\nvariable references.\n\nThe `run` function is run immediately as the page is loaded.  You may wish to wait until the entire page is loaded \nbefore you perform your logic, so you'd have to do the same stuff that you'd do in normal javascript embedded in\nwebpages.  For example, if you were using jquery, you'd be doing the standard `$(document).ready(function(){stuff})`\ntype of code to wait for the page to fully load.  Keep in mind that the run function is run inside the webpage\nso you won't have access to any scoped variables in nodejs.  The `callback` parameter should be called when you're\nready to pause the browser instance and pass control back to the nodejs world.\n\nThe `callback` function is run in the nodejs context so you'll have access to scoped variables as usual.  This \nfunction is called when you call the callback function from inside of `run()`.\n\n## Chimera options\n\n    var c = new Chimera({\n      userAgent: 'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6',\n      libraryCode: '(function() { window.my_special_variable = 1234; })()',\n      cookies: '',\n      disableImages: true\n    });\n    \nHere are all the possible options available when creating a new browser instance:\n\n- `userAgent`: Any string that represents a user agent.  By default it uses the one shown in the example, a windows chrome browser.\n- `libraryCode`: If you want to inject jquery into all your webpages, you should do something like `fs.readFileSync(\"jquery.js\")` here.\n- `cookies`: as seen in later examples, you can save the cookies from a previous browser instance and use them here\n- `disableImages`: If you don't need images in your scraper, this can drastically reduce memory and speed up webpages.  However, your screenshots may look like crap.\n\n## A simple login example\n\nIn the example code below, we show how to login to a website using a native mouse button click on the submit button, then load a second\nbrowser instance using the logged in cookies from the first browser instance.\n\n    var Chimera = require('chimera').Chimera;\n\n    var myUsername = \"my_username\";\n    var myPassword = \"my_password\";\n\n    var c = new Chimera();\n    c.perform({\n      url: \"http://www.mywebsite.com\",\n      locals: {\n        username: myUsername,\n        password: myPassword\n      },\n      run: function(callback) {\n        // find the form fields and press submit\n        pos = jQuery('#login-button').offset()\n        window.chimera.sendEvent(\"click\", pos.left + 10, pos.top + 10)\n      },\n      callback: function(err, result) {\n        // capture a screen shot\n        c.capture(\"screenshot.png\");\n\n        // save the cookies and close out the browser session\n        var cookies = c.cookies();\n        c.close();\n    \n        // Create a new browser session with cookies from the previous session\n        var c2 = new Chimera({\n          cookies: cookies\n        });\n        c2.perform({\n          url: \"http://www.mywebsite.com\",\n          run: function(callback) {\n            // You're logged in here!\n          },\n          callback: function(err, result) {\n            // capture a screen shot that shows we're logged in\n            c2.capture(\"screenshot_logged_in.png\");\n            c2.close();\n          }\n        });\n      }\n    });\n    \n### A few notes\n\nIn the example above, you may notice `window.chimera.sendEvent()`.  The `chimera` variable is a global inside webpages and\nallow you to call functions that you otherwise wouldn't be able to.  You can take a screenshot with `chimera.capture()` for\nexample.\n\nWhen we are in the callback() for the first browser instance, we nab the cookies via `c.cookies()`.  If you inspect the\ncookies, you'll see that it's just a giant string containing the domain, keys, and values.  This may contain http & https\ncookies as well, which are normally not accessible via javascript from inside the webpage.  You'll also probably notice\nthere are cookies from tracking companies like google analytics or mixpanel.  The cookies string will basically contain\neverything that a browser may have.  If you want to remove the google analytics cookies, you'll have to parse the cookie\nstring and remove them manually yourself.  There are many cookie parsers out there -- check out the one that is included in\nthe expressjs middleware if you need something quick and dirty.\n\n## A bad example\n\nHere's a few things that you should not do.\n\n    var c = new Chimera();\n    var fs = require('fs');\n    c.perform({\n      url: \"http://www.mywebsite.com\",\n      locals: {\n        fs: fs\n      },\n      run: function(callback) {\n        var os = require('os');\n      },\n      callback: function(err, result) {\n        \n      }\n    });\n    \nIn the above example, we try to pass the `fs` variable as a local variable.  We can't do this because `fs` cannot be \nturned into a json string.  Just because it looks like it might work, it won't.  The sandbox in the web browser\nprevents scoped variables from being available.\n\nA second thing wrong is that the `run()` function doesn't perform the callback function with `callback()`.  If you do\nthis, the context will never be passed back to the nodejs world so you'll be wondering why you can't scrape anything.\n\nThe third thing wrong here is that inside the `run()` function, we're trying to call `require('os')`.  The require\nfunction pulls from the nodejs scoped context which isn't available inside the webpage.  You only have access to typical\nvariables in a webpage like `window.document` etc.\n\n## Compiling your own version\n\nSince this library does use native libraries, I may not have a native version for your platform (people have been asking\nme about arm-linux and sunos).  Hopefully I can describe how one can compile this under your platform, and perhaps we can\nmove to something easier.  \n\n### Compiling on the mac:\n\nGetting a binary on the mac is fairly easy, but it does take a long time to compile Qt.  Unlike Linux, you don't need\nthe custom openssl included with chimera.  Here's the basic steps to take the mac:\n\n    ./scripts/compile_qt.sh\n    ./scripts/compile_binary.sh\n    \nThe final binary should be inside of node-chimera/lib.\n\n\n### Compiling on linux:\n\nYou'll need the ssl headers, freetype, and fontconfig libraries first, so you'll have to install with a command like:\n\n    apt-get install libfreetype6-dev libfontconfig1-dev libssl-dev\n\nSince nodejs comes with it's own version of ssl, we have to make Qt also use this version of ssl or else we'll have segfaults.\nCompile the openssl included first (we have some additional flags like `-fPIC` which allow the libraries to be statically included\nlater on).  Here are all the steps required to build chimera:\n\n    ./scripts/compile_openssl.sh\n    ./scripts/compile_qt.sh\n    ./scripts/compile_binary.sh\n    \nThe final chimera.node binary should exist inside the node-chimera/lib directory.  If you don't see it in there, something bad\nprobably happened along the way.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/deanmao/node-chimera/issues"
  },
  "_id": "chimera@0.3.2",
  "_from": "chimera@0.3.2"
}
